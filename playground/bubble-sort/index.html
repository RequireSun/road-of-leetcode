<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bubble Sort</title>
</head>
<body>
    <h1>See Chrome Devtools!</h1>

    <dl>
        <dt><h3>稳定性</h3></dt>
        <dd>稳定</dd>

        <dt><h3>复杂度</h3></dt>
        <dd>
            <p>O(n) ~ O(n^2)</p>

            <ul>
                <li>
                    <p><strong>最好情况</strong></p>
                    <p>数组有序</p>
                </li>
                <li>
                    <p><strong>最坏情况</strong></p>
                    <p>数组逆序</p>
                </li>
            </ul>
        </dd>

        <dt><h3>原理</h3></dt>
        <dd>从第一位开始遍历，每相近的两个进行比较，将更大的置后，这样一次循环之后即可确保最后一项即为最大值。这样循环遍历 n 次，每次遍历的长度都缩减 1（因为刚才的规律，所以 value(n) > value(n - 1)
            总是成立，不需要再遍历那么多了），最终结果就是有序的了。</dd>

        <dt><h3>优化</h3></dt>
        <dd>按照上文的说法做出来的算法是非常稳定的 O(n^2) 复杂度，无论如何都不会变。这是因为该算法无论数组是否已经有序，都会继续后面的计算，这非常没有必要。可以设置一个标志位，用于标记该次循环是否有进行过数值交换，如果没有发生过交换，则证明数组已有序，无需继续进行排序。</dd>
    </dl>
</body>
<script>
    const origin1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    const origin2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

    /**
     * 异或交欢数值
     * @param array
     * @param a
     * @param b
     */
    const swap = (array, a, b) => {
        array[a] ^= array[b];
        array[b] ^= array[a];
        array[a] ^= array[b];
    };

    const bubbleSort = (array) => {
        for (let i = 0, l = array.length; i < l; ++i) {
            // 加速计算用标志位, 如果这位在遍历完之后还是 false, 就证明整个数组有序了, 不需要再循环浪费时间了
            let isSwapped = false;

            for (let j = 0, k = l - i; j < k; ++j) {
                if (array[i] > array[j]) {
                    swap(array, i, j);
                    isSwapped = true;
                }
            }

            if (isSwapped === false) {
                break;
            }
        }
    };

    bubbleSort(origin1);
    bubbleSort(origin2);

    console.log('sort result1:', origin1);
    console.log('sort result2:', origin2);
</script>
</html>
