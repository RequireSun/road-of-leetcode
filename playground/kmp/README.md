KMP 算法
===

传统字符串搜索算法最大的问题就是当我在某一位上匹配失败以后, 要整体回溯, 如下:

```
abcdabcdabdabc

abcdabd
```

当第 7 个 c 与 d 不匹配时, 传统做法是后移一位, 从原串第 2 个位置 (b) 与子串第一个位置 (a) 进行匹配.

而我们可以非常直观的看出, 子串的 5~6 位与 1~2 位实际上是一样的. 假如说我已经运行到了 7 的位置, 那么原在 7 之前的部位一定是 ab, 我 1 2 位也是 ab, 7 匹配不上的时候, 直接匹配 3 就可以了, 因为前两位百分百是 ab, 和子串 1 2 位相同.

KMP 做法所做的就是模拟上述流程, 根据子串的 __当前位置与子串头部公共头长度__ 来让子串的可复用部分被尽量复用, 不再从头开始匹配.

这里的关键便是 __最大公共前缀长度数组__ 计算这一步:

```
abcdabd
```

根据上面的规律, 这里我们可以手动给每一位做标记:

1. a, 因为是第一位, 如果还不匹配的话就需要直接去比较下一个字符了, 所以这里是 -1, 表示目标串匹配位置向后移动一位.

1. b, 第二位, 因为它的前一位就是第一位, 所以假如这一位不匹配, 应该从子串的开头开始匹配, 所以这里是 0.

1. c, 第三位, 因为它的前一位跟第一位不一样, 所以它和首部没有公共子串, 假如不匹配就要从头开始匹配, 所以这里是 0.

1. d, 第四位, 同上.

1. a, 第五位, 同上 (注意条件是上一位要匹配的上, 所以这一位和首部匹配, 但它的值也是 0).

1. b, 第六位, 因为前一位和子串首部相同, 所以本位不同时, 前一位是可以复用, 不需要重新比较的. 只需要将子串移动到第二个位置, 比较一下这一位是否匹配就好了, 所以这里是 1.

1. d, 第七位, 因为前两位和首部相同, 所以本位不对的时候, 可以直接平移子串到 3 的位置, 复用前两位的比较结果, 所以这里的值是 2.

转化为代码语言, 便是:

1. 第一位一定是 -1.

1. 第二位一定是 0.

1. 在前一位和首部能匹配上的情况下, 后一位的平移值就是前一位平移值 +1.

1. 一个都不匹配的话就从 0 开始重新匹配. 

后来在实践中我们又发现, 当前一位和首部匹配不上时, 也是有可能会有可复用部分的, 比如:

```
abcabcabcabcabcabcde

abcabcabcde
```

在最后一位 e 没匹配上时, 实际上不应该
